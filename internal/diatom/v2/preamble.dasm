jmp
@init


( Instructions )

.codeword @ @ .end
.codeword ! ! .end
.codeword + + .end
.codeword - - .end
.codeword * * .end
.codeword / / .end
.codeword % % .end
.codeword dup dup .end
.codeword drop drop .end
.codeword swap swap .end
.codeword over over .end
.codeword key key .end
.codeword emit emit .end
.codeword = = .end
.codeword ~ ~ .end
.codeword & & .end
.codeword | | .end
.codeword < < .end
.codeword > > .end
.codeword rpop rpop rpop swap rpush .end
.codeword rpush rpop swap rpush rpush .end
.codeword b@ b@ .end
.codeword b! b! .end


( Utilities )

.codeword word-size const 4 .end
.codeword w+ const 4 + .end
.codeword true const -1 .end
.codeword false const 0 .end
:'call' const 5 ret
:'const' const 7 ret
:'ret' const 2 ret

( Unsafe )

( ptr -- )
.codeword unsafe.stack-call
  rpush
.end


( Integer )

( int -- int )
( Returns the count of digits of the given number. The count will
  include the minus sign of negative numbers. )
:int.digit-count
  dup const -1 > const 1 +
  swap
:int.digit-count-loop
  swap const 1 + swap
  const 10 /
  dup const 0 = ~ cjmp @int.digit-count-loop
  drop ret


( Math )

( int int -- int )
:math.max
  over over < cjmp @math.max-else
  drop
  ret
:math.max-else
  swap drop
  ret

( int int -- int )
:math.min
  over over > cjmp @math.max-else
  drop
  ret
:math.min-else
  swap drop
  ret

( int -- int )
:math.abs
  dup const 0 < cjmp @math.abs-invert
  ret
:math.abs-invert
  const -1 * ret

( -- int )
:math.int-max const 2147483647 ret

( -- int )
:math.int-min const -2147483648 ret

( int -- bool )
:math.saturated?
  dup call @math.int-max =
  swap call @math.int-min = |
  ret

( int -- int )
:math.absolute
  dup const 0 < cjmp @math.absolute-negative
  ret
:math.absolute-negative
  const -1 * ret


( Arrays )

( ptr capacity -- ptr )
:array.init
  call @math.abs
  over const 1 + b!
  dup const 0 swap b!
  ret

( ptr -- int )
:array.length b@ ret

( ptr -- int )
:array.capacity const 1 + b@ ret

( x ptr -- )
:array.append
  dup b@ const 1 +
  over const 1 + b@
  % over over swap b!
  + const 1 + b!
  ret

( int ptr -- ptr )
:array.indexed
  swap over b@ %
  call @math.abs +
  const 2 +
  ret

( int ptr -- x )
:array.get call @array.indexed b@ ret

( x int ptr -- )
:array.set call @array.indexed b! ret

( ptr -- )
:array.clear const 0 swap b! ret

( ptr ptr -- bool )
:array.equal?
  over call @array.length
  over call @array.length
  dup const 1 - rpush
  = ~ cjmp @array.equal?-false
:array.equal?-loop
  over rpeek swap call @array.get
  over rpeek swap call @array.get
  = ~ cjmp @array.equal?-false
  rpop const 1 - rpush
  rpeek const -1 > cjmp @array.equal?-loop
  rpop drop drop drop
  call @true
  ret
:array.equal?-false
  rpop drop drop drop
  call @false
  ret

( src dest -- )
:array.copy
  over call @array.capacity
  over call @array.capacity
  call @math.min rpush
  
  over call @array.length
  over call @array.length
  call @math.max
  rpeek call @math.min

  over b!
:array.copy-loop
  rpeek const 1 < cjmp @array.copy-end

  over rpeek swap call @array.get
  over rpeek swap call @array.set

  rpop const 1 - rpush jmp @array.copy-loop
:array.copy-end
  rpop drop drop drop ret

( Char )

( char -- bool )
:char.blank? const 33 < ret

( char -- bool )
:char.number?
  dup const 47 >
  swap const 58 < &
  ret


( String )

( ptr -- int )
:string.sign
  const 0 swap call @array.get
  const 45 = cjmp @string.sign-negative
  const 1
  ret
:string.sign-negative
  const -1
  ret

( ptr -- int )
:string.parse-number
  dup call @string.sign swap
  const 0 rpush const 0
:string.parse-number-loop
  over call @array.length rpeek > ~ cjmp @string.parse-number-end
  const 10 *
  over rpeek swap call @array.get
  dup const 45 = cjmp @string.parse-number-skip
  dup call @char.number? ~ cjmp @string.parse-number-error
  const 48 - +
  rpop const 1 + rpush
  jmp @string.parse-number-loop
:string.parse-number-skip
  drop
  rpop const 1 + rpush
  jmp @string.parse-number-loop
:string.parse-number-error
  drop drop call @math.int-min
:string.parse-number-end
  rpop drop swap drop * ret

( ptr -- int )
:string.print
  const 0 rpush
:string.print-loop
  dup call @array.length rpeek > ~ cjmp @string.print-end
  rpeek over call @array.get emit
  rpop const 1 + rpush
  jmp @string.print-loop
:string.print-end
  rpop drop drop ret

( int -- char )
:last-digit-to-char
  call @math.absolute
  const 10 %
  const 48 +
  ret

( int len ptr -- )
:store-digit
  rpush rpush
  call @last-digit-to-char
  rpop rpop call @array.set
  ret

( int ptr -- )
:string.from-number
  rpush
  dup call @int.digit-count
  dup rpeek b!
:string.from-number-loop
  const 1 -
  over over rpeek call @store-digit
  dup const 0 = cjmp @string.from-number-end
  swap const 10 / swap
  jmp @string.from-number-loop
:string.from-number-end
  drop drop
  const 0 rpeek call @array.get const 48 =
  rpeek call @array.length const 1 >
  & cjmp @string.from-number-minus
  rpop drop ret
:string.from-number-minus
  const 45 const 0 rpop call @array.set
  ret


( Word Handling )

.var word.buffer 34 .end

:non-blank-key
  key dup call @char.blank? ~ cjmp @non-blank-key-end
  drop jmp @non-blank-key
:non-blank-key-end
  ret

( -- )
.codeword word.read
  const @_var-word.buffer const 32 call @array.init rpush
  call @non-blank-key
:word.read-loop
  rpeek call @array.append
  key dup call @char.blank? ~ cjmp @word.read-loop
  drop rpop drop
.end

( -- )
.codeword word.print
  const @_var-word.buffer call @string.print
.end

( -- )
.codeword .
  dup
  call @word.buffer
  call @string.from-number
  call @word.print
  const 10 emit
.end

( ptr -- ptr )
.codeword word.flags
  call @w+
.end

( ptr -- ptr )
.codeword word.name
  call @w+ const 1 +
.end

( ptr -- ptr )
.codeword word.code
  call @word.name dup b@
  const 2 + +
.end

( -- )
.codeword word.immediate
  call @word.latest @ call @word.flags dup b@
  const 2 | swap b!
.end

( ptr -- bool )
.codeword word.immediate?
  call @word.flags b@
  const 2 &
  const 2 =
.end

( -- )
.codeword word.hide
  call @word.latest @ call @word.flags dup b@
  const 1 | swap b!
.end

( -- )
.codeword word.unhide
  call @word.latest @ call @word.flags dup b@
  const 254 & swap b!
.end

( ptr -- bool )
.codeword word.hidden?
  call @word.flags b@
  const 1 &
  const 1 =
.end

( -- ptr )
( Returns a pointer to the matching word or 0 if no match could be
found. )
.codeword word.find
  call @word.latest @ rpush
  
:word.find-loop
  rpeek const 0 = cjmp @word.find-exit
  rpeek call @word.name call @word.buffer call @array.equal?
  rpeek call @word.hidden? ~
  & cjmp @word.find-exit
  rpop @ rpush jmp @word.find-loop
  
:word.find-exit
  rpop
.end

.var word.compile-state 4 .end
.var word.here 4 .end

( ptr -- )
:word.append
  call @word.here @ !
  call @word.here dup @ call @w+ swap !
  ret
  
( ptr -- )
:word.append-byte
  call @word.here @ b!
  call @word.here dup @ const 1 + swap !
  ret

( -- )
:word.create-header
  call @word.here @
  call @word.latest @ call @word.append
  call @word.latest !
  const 0 call @word.append-byte

  call @word.buffer
  call @word.here @
  over call @array.length
  call @array.init
  call @array.copy

  call @word.latest @ call @word.code
  call @word.here !
  ret

( -- )
( Disables compilation mode. )
.immediate-codeword [
  call @false call @word.compile-state !
.end

( -- )
( Enables compilation mode. )
.immediate-codeword ]
  call @true call @word.compile-state !
.end

( -- )
( Reads words from stdin and switches into compilation mode. )
.codeword :
  call @word.read
  call @word.create-header
  call @word.hide
  call @]
.end

.immediate-codeword ;
  call @'ret' call @word.append-byte
  call @word.unhide
  call @[
.end

( -- )
.codeword word.interpret
  call @word.read call @word.find
  dup const 0 = cjmp @word.interpret-number
  dup call @word.code
  
  swap call @word.immediate? ~
  call @word.compile-state @
  & cjmp @word.interpret-compile

  call @unsafe.stack-call
  jmp @word.interpret

:word.interpret-compile
  call @'call' call @word.append-byte
  call @word.append
  jmp @word.interpret

:word.interpret-number
  drop call @word.buffer call @string.parse-number
  dup call @math.int-min = cjmp @word.interpret-error
  call @word.compile-state @ cjmp @word.interpret-compile-number
  jmp @word.interpret

:word.interpret-compile-number
  call @'const' call @word.append-byte
  call @word.append
  jmp @word.interpret
  
:word.interpret-error
  .string Word not found. .end
  call @string.print
.end


( This line is used to inject test code. )
( {{main}} )


( THIS MUST BE THE LAST WORD DECLARATION OTHERWHISE NEW WORD
DEFINITIONS OVERWRITE EXISTING ONES. )
.var word.latest 4 .end

:init
  const @_dict-word.latest const @_var-word.latest !
  const @here-address const @_var-word.here !
  jmp @main

:here-address