jmp
@main


( Instructions )

.codeword @ @ .end
.codeword ! ! .end
.codeword + + .end
.codeword - - .end
.codeword * * .end
.codeword / / .end
.codeword % % .end
.codeword dup dup .end
.codeword drop drop .end
.codeword swap swap .end
.codeword over over .end
.codeword key key .end
.codeword emit emit .end
.codeword = = .end
.codeword ~ ~ .end
.codeword & & .end
.codeword | | .end
.codeword < < .end
.codeword > > .end
.codeword rpop rpop rpop swap rpush .end
.codeword rpush rpop swap rpush rpush .end
.codeword b@ b@ .end
.codeword b! b! .end


( Utilities )

.codeword int-max const 2147483647 .end
.codeword int-min const -2147483648 .end
.codeword word-size const 4 .end
.codeword w+ const 4 + .end
.codeword true const -1 .end
.codeword false const 0 .end

( int int -- int )
:max
  over over < jmp @max-else
  drop
  ret
:max-else
  swap drop
  ret

( Arrays )

( ptr capacity -- )
:array.init
  over const 1 + b!
  dup const 0 swap b!
  ret

( ptr -- int )
:array.length b@ ret

( ptr -- int )
:array.capacity const 1 + b@ ret

( x ptr -- )
:array.append
  dup b@ const 1 +
  over const 1 + b@
  % over over swap b!
  + const 1 + b!
  ret

( int ptr -- ptr )
:array.indexed
  swap over b@ %
  + const 2 +
  ret

( int ptr -- x )
:array.get call @array.indexed b@ ret

( x int ptr -- )
:array.set call @array.indexed b! ret

( from to -- )
:array.copy
  over call @array.length
  over call @array.length
  call @max
:array.copy-loop
( TODO )

( ptr ptr -- bool )
:array.compare

( ptr -- )
:array.clear const 0 !

( Chars )
:char.blank?

( Strings )
( TODO: Implement string handling functions. )
( TODO: How should a string even look like in memory? )
:str.len
:str.clear
:str.append

( Word Handling )
.var word-buf 32 .end

.codeword word
( TODO: Reads the next word from stdin )
.end