* Diatom

A stack VM & Forth-like language implementation.

** Goals

   The goal of this project is to create a minimal viable programming language to
   learn more about the fundamentals of computing but also to see how featureful a
   language really needs to be to create useful software.

   The priorities are:

   1. Simplicity - simple to use but also simple to implement
   2. Portability - be the most portable virtual machine there is
   3. Correctness - the obvious way to do something should lead towards
	  predictable results
   4. Efficiency - be reasonable efficient in both time and space requirements but
	  always provide an escape hatch to the host language

** Problems

   The `exit` instruction is equal to 0 which means whenever rogue code jumps to a
   wrong memory address the VM just exists gracefully, which is not exactly what
   we want. Maybe we can introduce an additional instruction `abort` for value 0
   and move `exit` to 1 so we can distinguish this.

** TODO

  - [ ] Implement `quit` and figure out how to clear the stacks
  - [ ] Reorder instructions so `ret`, `const` & `call` have well-defined values
  - [ ] Implement debugging tool
  - [ ] Start the repl with `diatom repl`
  - [ ] Read programs from stdin instead of files
  - [ ] Bootstrap Forth interpreter
  - [ ] Use it in a _real world_ project

** Implementation Details

   TBD

*** Booleans

	For proper booleans ~false~ is equal to the decimal value zero,
	~true~ to the decimal value -1. This has the advantage that a
	binary not can toggle between the two states.

	Improper booleans (a.k.a. everything else) are treated as ~true~.
	
*** Charrays

	Char arrays have the following memory-layout:
	
    | 1 byte | 1 byte   | n bytes |
    |--------+----------+---------|
    | Length | Capacity | Data    |

*** Dictionary

	The header of every word has the following memory-layout:
	
    | Size    | Description              |
    |---------+--------------------------|
    | 1 Byte  | Pointer to previous word |
    | 1 Byte  | Flags                    |
    | 1 Byte  | Length                   |
    | 1 Byte  | Capacity                 |
    | n Bytes | Name of the word         |
    | n Bytes | Code                     |

	This wastes some space but makes the implementation easier as one
	can use regular array functions to manipulate the word names.

	The flags byte contains the following bits:

    | Bit | Description |
    |-----+-------------|
    |   0 | Hidden      |
    |   1 | Immediate   |
    |   2 | Reserved    |
    |   3 | Reserved    |
    |   4 | Reserved    |
    |   5 | Reserved    |
    |   6 | Reserved    |
    |   7 | Reserved    |
	
